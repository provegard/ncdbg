plugins {
    id "com.github.maiflai.scalatest" version "0.25"
    id 'com.palantir.git-version' version '0.5.3'
}

allprojects {
    apply plugin: 'scala'
    apply plugin: 'application'

    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    repositories {
        mavenCentral()
        maven { url "https://jitpack.io" }
    }
}

group 'com.programmaticallyspeaking'
version gitVersion()

def toolsJar = org.gradle.internal.jvm.Jvm.current().toolsJar

mainClassName = "com.programmaticallyspeaking.ncd.boot.Boot"

def generatedResourcesFolder = "$buildDir/generated-resources"

// For the application plugin
applicationName = "ncdbg"

project(':repl') {
    mainClassName = "com.programmaticallyspeaking.repl.Main"

    dependencies {
        compile rootProject
    }

    run {
        standardInput = System.in
        applicationDefaultJvmArgs = ["-Xdebug", "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=localhost:7777"]
    }
}

sourceSets {
    main {
        output.dir(generatedResourcesFolder, builtBy: 'generateResources')
    }
}

task generateResources {
    doLast {
        mkdir generatedResourcesFolder
        def buildProps = new File(generatedResourcesFolder, "build.properties")
        def javaVer = org.gradle.internal.jvm.Jvm.current().javaVersion
        buildProps.text = """version=$version
build_java_version=$javaVer
"""
    }
}

test {
    // Always run tests!
    outputs.upToDateWhen {false}

    systemProperty "SelectiveActorLogging.suppress", "true"
    systemProperty "logback.configurationFile", "logback-off.xml"

    // Don't run tests in parallel. Since we listen for log events from MemoryAppender to include in the failure output,
    // running tests in parallel results in too much noise.
    maxParallelForks = 1
}

run {
    // Useful for testing command-line argument parsing using "gradle run -Pargs='...'"
    if (project.hasProperty('args')){
        args project.args.split('\\s+')
    }
}

task repl(dependsOn: project(':repl').run)

dependencies {
    def logbackVersion = '1.1.7'
    def akkaHttpVersion = '10.1.9'
    def akkaVersion = '2.5.25'
    def scalaVersion = '2.12.11'

    // needed for gradle-scalatest
    testRuntimeOnly 'org.pegdown:pegdown:1.6.0'

    testImplementation group: 'org.scalatest', name: 'scalatest_2.12', version: '3.0.1'
    testImplementation group: 'org.scalacheck', name: 'scalacheck_2.12', version: '1.13.4'

    testImplementation group: 'com.typesafe.akka', name: 'akka-http-testkit_2.12', version: akkaHttpVersion
    testImplementation group: 'com.typesafe.akka', name: 'akka-stream-testkit_2.12', version: akkaVersion

    testImplementation group: 'org.mockito', name: 'mockito-core', version: '2.2.27'
    testImplementation group: 'org.java-websocket', name: 'Java-WebSocket', version: '1.3.0'

    testCompile files("lib/script.jar")

    if (toolsJar != null) {
        compile files(toolsJar)
    }

    implementation group: 'ch.qos.logback', name: 'logback-classic', version: logbackVersion

    implementation group: 'com.programmaticallyspeaking', name: 'tinyws', version: '0.0.6'

    implementation group: 'org.slf4s', name: 'slf4s-api_2.12', version: '1.7.25'

    implementation group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: akkaVersion

    implementation group: 'com.fasterxml.jackson.module', name: 'jackson-module-scala_2.12', version: '2.9.6'

    // Must be compile for repl to work. What should it be replaced with?
    compile "org.scala-lang:scala-library:$scalaVersion"

    implementation group: 'org.rogach', name: 'scallop_2.12', version: '2.1.0'

    implementation group: 'com.google.javascript', name: 'closure-compiler', version: 'v20180204'
}

// Exclude tools.jar from the distribution since we want to use the one from the user's JDK.
distZip {
    excludes += ['**/tools.jar']
}

// Only report failed tests on the console. This makes it easier to spot the failures...
tasks.withType(Test) {
    testLogging {
        events = ['FAILED']
    }
}

// Excluding tools.jar doesn't remove it from the start script, where it's assumed to be in the local lib folder.
// Do some text replacement to change its location to lib under JAVA_HOME instead.
startScripts {
    doLast {
        def windowsScriptFile = file getWindowsScript()
        def unixScriptFile    = file getUnixScript()
        if (toolsJar != null) {
            windowsScriptFile.text = windowsScriptFile.text.replace('%APP_HOME%\\lib\\tools.jar', '%JAVA_HOME%\\lib\\tools.jar')
            // If JAVA_HOME is a Windows path (e.g. under MinGW), we need to remove the colon (since that's the class path
            // separator) and prefix with a slash to make Java understand that it's a path. This has been tested in
            // Windows with Git Bash (MINGW64) and in Linux.
            // Note: Variable substitution doesn't work with dash, which is the sh replacement on Linux,
            // hence the use of echo + tr.
            unixScriptFile.text = unixScriptFile.text.replace('$APP_HOME/lib/tools.jar', '/$(echo $JAVA_HOME | tr -d ":")/lib/tools.jar')
        } else {
            // Java distribution used for building doesn't include tools.jar, so append it to CLASSPATH
            windowsScriptFile.text = windowsScriptFile.text.replaceFirst('(CLASSPATH=.*)', '$1;%JAVA_HOME%\\\\lib\\\\tools.jar')
            unixScriptFile.text = unixScriptFile.text.replaceFirst('(CLASSPATH=.*)', '$1:/\\$\\(echo \\$JAVA_HOME | tr -d ":"\\)/lib/tools.jar')
        }
    }
}
